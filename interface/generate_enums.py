import xml.parsers.expat
import sys
import pathlib


class DBusXMLEnumParser:
    def __init__(self, xml_data, prefix, infile, outfile):
        self.prefix = prefix
        self._parser = xml.parsers.expat.ParserCreate()
        self._parser.StartElementHandler = self.handle_start_element
        self._parser.EndElementHandler = self.handle_end_element
        self._parser.CharacterDataHandler = self.handle_char_data

        self._enum_data = None
        self._in_docstring = False
        self._in_enum_value = False

        self._poutfile = pathlib.Path(outfile)
        self._header = self._poutfile.suffix == ".h"
        self._writer = self._poutfile.open("w")
        self._writer.write(f"/* Autogenerated from {pathlib.Path(infile).name} */\n\n")

        if self._header:
            self._writer.write("#pragma once\n\n")
            self._writer.write("#include <glib-object.h>\n\n")
            self._writer.write("G_BEGIN_DECLS\n\n")
        else:
            self._writer.write(f'#include "{self._poutfile.stem}.h"\n\n')
        self._parser.Parse(xml_data)

        if self._header:
            self._writer.write("\nG_END_DECLS\n\n")
        self._writer.close()

    def print_enum_impl(self):
        full_name = f"{self.prefix}_{self._enum_data['name']}"
        camel_case_name = "".join([a.capitalize() for a in full_name.split("_")])
        self._writer.write(f"GType\n{full_name.lower()}_get_type (void)\n{{\n")
        self._writer.write("  static gsize g_define_type_id__volatile = 0;\n\n")
        self._writer.write(
            "  if (g_once_init_enter (&g_define_type_id__volatile))\n    {\n"
        )
        if self._enum_data["is_flags"]:
            self._writer.write("      static const GFlagsValue values[] = {\n")
        else:
            self._writer.write("      static const GEnumValue values[] = {\n")
        values = []
        for val in self._enum_data["values"]:
            dashified = "-".join(
                val["name"][len(self._enum_data["name"]) + 1 :].lower().split("_")
            )
            triad = [
                f"{self.prefix.upper()}_{val['name']}",
                f"\"{self.prefix.upper()}_{val['name']}\"",
                f'"{dashified}"',
            ]
            values.append(triad)
        values.append(["0", "NULL", "NULL"])
        a = [f"        {{ {', '.join(triad)} }}" for triad in values]
        self._writer.write(",\n".join(a))
        self._writer.write("\n      };\n")
        self._writer.write("      GType g_define_type_id =\n")
        if self._enum_data["is_flags"]:
            self._writer.write(
                f'        g_flags_register_static (g_intern_static_string ("{camel_case_name}"), values);\n'
            )
        else:
            self._writer.write(
                f'        g_enum_register_static (g_intern_static_string ("{camel_case_name}"), values);\n'
            )
        self._writer.write(
            "      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);\n"
        )
        self._writer.write("    }\n\n")
        self._writer.write("  return g_define_type_id__volatile;\n")
        self._writer.write("}\n\n")

    def print_enum_header(self):
        full_name = f"{self.prefix}_{self._enum_data['name']}"
        camel_case_name = "".join([a.capitalize() for a in full_name.split("_")])
        self._writer.write("\n/**\n")
        self._writer.write(f" * {camel_case_name}:\n")
        for val in self._enum_data["values"]:
            self._writer.write(
                f" * @{self.prefix.upper()}_{val['name']}: {' '.join(val['docstring'])}\n"
            )
        self._writer.write(" *\n")
        self._writer.write(f" * {' '.join(self._enum_data['docstring'])}\n")
        self._writer.write(" */\n")

        self._writer.write(f"typedef enum /*<underscore_name={full_name.lower()}>*/\n")
        self._writer.write("{\n")
        for val in self._enum_data["values"]:
            self._writer.write(
                f"  {self.prefix.upper()}_{val['name']} = {val['value']},\n"
            )
        self._writer.write("} %s;\n\n" % camel_case_name)
        self._writer.write(
            f"\nGType {full_name.lower()}_get_type (void) G_GNUC_CONST;\n"
        )
        self._writer.write(
            f"#define {self.prefix.upper()}_TYPE_{self._enum_data['name']} ({full_name.lower()}_get_type ())\n"
        )

    def handle_start_element(self, name, attrs):
        if name == "tp:enum" or name == "tp:flags":
            self._enum_data = {
                "name": attrs["name"],
                "values": [],
                "docstring": [],
                "is_flags": name == "tp:flags",
            }
        elif name == "tp:enumvalue" or name == "tp:flag":
            if (name == "tp:flag") != (self._enum_data["is_flags"]):
                raise Exception("Flags embedded in enum or vice-versa")
            self._enum_data["values"].append(
                {
                    "name": f"{self._enum_data['name']}_{attrs['suffix']}",
                    "value": attrs["value"],
                    "docstring": [],
                }
            )
            self._in_enum_value = True
        elif name == "tp:docstring":
            self._in_docstring = True

    def handle_char_data(self, data):
        text = data.strip()
        if not text:
            return
        if self._in_docstring and self._in_enum_value:
            self._enum_data["values"][-1]["docstring"].append(text)
        else:
            self._enum_data["docstring"].append(text)

    def handle_end_element(self, name):
        if name == "tp:enum" or name == "tp:flags":
            if self._header:
                self.print_enum_header()
            else:
                self.print_enum_impl()
            self._enum_data = None
        elif name == "tp:enumvalue" or name == "tp:flag":
            self._in_enum_value = False
        elif name == "tp:docstring":
            self._in_docstring = False


if __name__ == "__main__":
    prefix, infile, outfile = sys.argv[-3:]
    data = open(infile)
    parser = DBusXMLEnumParser(data.read(), prefix, infile, outfile)
